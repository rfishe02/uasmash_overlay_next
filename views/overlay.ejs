<html>

<head>
  <title>UA Smash Overlay</title>

  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.9.1/font/bootstrap-icons.css">

  <link rel="stylesheet" href="/stylesheets/overlay.css">

  <style>
    body { background-color: rgba(0, 0, 0, 0);
      margin: 0px auto;
      overflow: hidden;
    }
  </style>

  <!-- jQuery first, then Popper.js, then Bootstrap JS -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.5/dist/umd/popper.min.js" integrity="sha384-Xe+8cL9oJa6tN/veChSP7q+mnSPaj5Bcu9mPX5F5xIGE0DVittaqT5lorf0EI7Vk" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.min.js" integrity="sha384-ODmDIVzN+pFdexxHEHFBQH3/9/vQ9uori45z4JjnFsRydbmQbmL5t1tQ0culUzyK" crossorigin="anonymous"></script>

  <script src="https://unpkg.com/vue@3"></script>

  <script src="/socket.io/socket.io.js"></script>

</head>

<body>
  <div id="app">

      <div class="container-fluid" style="width: 1920px; height: 1080px;">

        <gameplay-overlay v-if="type == 0"
        :p1name="p1Name"
        :p2name="p2Name"
        :p1score="p1Score"
        :p2score="p2Score"
        :eventround="eventRound"
        :bestof="bestOf"
        :bracketType="bracketType"
        :p1members="p1.members"
        :p2members="p2.members"
        > </gameplay-overlay>

        <!--
        <div class="row justify-content-center fixed-bottom" v-if="type == 1">
          <div class="col-4 white-border mb-3">
            {{p1Name}}
          </div>
          <div class="col-1"></div>
          <div class="col-4 white-border mb-3">
            {{p2Name}}
          </div>
        </div>-->

      </div>

    </div>

  </div>
</body>

<script type="module">


  import GameplayOverlay from '/javascripts/GameplayOverlay.js'

  const { createApp} = Vue

  const socket = io("http://" + window.location.hostname + ":3000", {
    reconnectionDelayMax: 10000,
    autoConnect: false,
  })

  socket.on("overlay-push", ({ content, from }) => {
    try {

      overlayApp.setOverlayValues(content["teamOne"],content["teamTwo"],content["bracketType"],content["eventRound"],content["bestOf"])
      overlayApp.saveOverlayValuesToSession()

    } catch(e) {
      console.log(e)
    }
  })

  socket.on("score-push", ({ content, from }) => {

    overlayApp.p1Score = content["p1Score"] == null ? "" : content["p1Score"]
    overlayApp.p2Score = content["p2Score"] == null ? "" : content["p2Score"]

    if(overlayApp.p1 != null) {
      overlayApp.p1.score = overlayApp.p1Score
      sessionStorage.setItem("teamOne",JSON.stringify(overlayApp.p1))
    }
    if(overlayApp.p2 != null) {
      overlayApp.p2.score = overlayApp.p2Score
      sessionStorage.setItem("teamTwo",JSON.stringify(overlayApp.p2))
    }

  })

  socket.on("disconnect", () => {
    socket.connect()
  })

  const overlayApp = createApp({
    data() {
      return {
        host: window.location.hostname,
        port: ":3000",
        p1: {},
        p2: {},
        p1Name: "",
        p2Name: "",
        p1Score: "",
        p2Score: "",
        bracketType: "",
        eventRound:"",
        bestOf:"",
        socket: socket,
        type: 0,
        winnerBestOfStart: 0,
        loserBestOfStart: 0,
        finalsOrder : {
          'Quarter-Final':0,
          'Semi-Final':1,
          'Final':2,
          'Grand Final': 3,
        }
      }
    },
    mounted() {
      const urlParams = new URLSearchParams(window.location.search)
      const room = urlParams.get('id')
      const type = urlParams.get('type')

      if(room != null) {
        this.socket.connect()
        this.socket.emit("subscribe",room)
      }
      if(type != null) {
        this.type = type
      }

      const teamOne = sessionStorage.getItem("teamOne") == null ? {} : JSON.parse(sessionStorage.getItem("teamOne"))
      const teamTwo = sessionStorage.getItem("teamTwo") == null ? {} : JSON.parse(sessionStorage.getItem("teamTwo"))

      this.setOverlayValues(teamOne,teamTwo,sessionStorage.getItem("bracketType"),sessionStorage.getItem("eventRound"),sessionStorage.getItem("bestOf"))

      const slug = urlParams.get('slug')
      const poll = urlParams.get('poll')

      const winnerBestOfStart = urlParams.get('winnerBestOfStart') == null ? 0 : this.finalsOrder[urlParams.get('winnerBestOfStart')]
      const loserBestOfStart = urlParams.get('loserBestOfStart') == null ? 0 : this.finalsOrder[urlParams.get('loserBestOfStart')]

      if(winnerBestOfStart != null) {
        this.winnerBestOfStart = winnerBestOfStart
      }
      if(loserBestOfStart != null) {
        this.loserBestOfStart = loserBestOfStart
      }

      if(slug != null && poll != null) {
        if(poll == 'true') {
          setInterval(function(){
            overlayApp.pollSmashGGAPI(slug)
          }, 5000);
        }
      }

    },
    methods : {
      async pollSmashGGAPI(slug) {
        try {
          const key = '<%= apiKey %>'
          const data = await this.queryStreamQueueSmashGG(key,slug)

          if(data.length == 0) {

            this.setOverlayValues({},{},'','','')
            this.saveOverlayValuesToSession()

          } else {

            const winnerBestOfStart = 'Final'
            const loserBestOfStart = 'Final'

            //var previousStartedAt = Date.now()
            var previousStartedAt = 0
            data.forEach((set) => {
              if(set.state == 2) {

                if(set.startedAt > previousStartedAt) {

                  const eventRound = set.fullRoundText == null ? '' : set.fullRoundText
                  const order = this.finalsOrder[eventRound.replace(/Winners |Losers /g,'')]
                  var bestOfValue = 'Best of 3'

                  if(order != null) {
                    if(eventRound.indexOf('Winner') >= 0) {
                      if(order >= this.winnerBestOfStart) {
                        bestOfValue = 'Best of 5'
                      }
                    } else {
                      if(order >= this.loserBestOfStart) {
                        bestOfValue = 'Best of 5'
                      }
                    }
                  }

                  this.setOverlayValues(set.teamOne,set.teamTwo,set.phaseName,eventRound,bestOfValue)
                  this.saveOverlayValuesToSession()
                }

                previousStartedAt = set.startedAt
              }
            })

          }

        } catch(e) {
          console.log(e)
        }
      },
      async queryStreamQueueSmashGG(key,slug){
        const streamQueryData = []
        try {
          const query = `
          query TournamentQuery($slug: String) {
      		tournament(slug: $slug){
      			id
      			name
          	slug
          	state
          	streamQueue {
              sets {
                completedAt
                createdAt
                event {
                  id
                  name
                }
                fullRoundText
                games {
                  orderNum
                  winnerId
                }
                phaseGroup {
                  bracketType
                  phase {
                    name
                  }
                }
                setGamesType
                slots {
                  entrant {
                    id
                    name
                    participants {
                      prefix
                      gamerTag
                      user {
                        id
                        name
                        genderPronoun
                        authorizations {
                          externalUsername
                          type
                        }
                      }
                    }
                  }
                }
                startAt
                startedAt
                state
                totalGames
              }
          	}
      		}
      	}`

          const response = await fetch("https://api.start.gg/gql/alpha", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
              Authorization: "Bearer " + key,
            },
            body: JSON.stringify({
              query,
              variables: { slug: slug },
            }),
          })

          if(response.ok) {
            const data = await response.json()

            if (data.data != null) {
              if (data.data.tournament != null) {
                if(data.data.tournament.streamQueue != null) {
                  if(data.data.tournament.streamQueue[0].sets != null){

                    data.data.tournament.streamQueue[0].sets.forEach((set) => {
                      const s = {
                        eventName: '',
                        phaseName: '',
                        fullRoundText: '',
                        state: '',
                        startedAt: '',
                      }

                      s.fullRoundText = set.fullRoundText == null ? '' : set.fullRoundText
                      s.state = set.state == null ? '' : set.state
                      s.startedAt = set.startedAt == null ? '' : set.startedAt

                      if(set.event != null) {
                        s.eventName = set.event.name == null ? '' : set.event.name
                      }
                      if(set.phaseGroup != null) {
                        if(set.phaseGroup.phase != null) {
                          s.phaseName = set.phaseGroup.phase.name == null ? '' : set.phaseGroup.phase.name
                        }
                      }

                      s.teamOne = this.getTeamData(set,0)
                      s.teamTwo = this.getTeamData(set,1)

                      streamQueryData.push(s)
                    })

                  }
                }
              }
            }

          }

        } catch(e) {
            console.log(e)
        }

        return streamQueryData
      },
      getTeamData(set, slotIndex) {
        const team = { entrantID: '', name: '', score: '', members: [] }

        if(set.slots != null) {
          const slots = set.slots[slotIndex]

          if (slots != null) {
            if (slots.entrant != null) {
              team.entrantID = slots.entrant.id
              team.name = slots.entrant.name.slice(slots.entrant.name.indexOf("| ") + 1,slots.entrant.name.length).trim()

              if (slots.entrant.participants != null) {
                slots.entrant.participants.forEach((player) => {

                  const item = {}
                  item.name = player.gamerTag.slice(player.gamerTag.indexOf("| ") + 1,player.gamerTag.length).trim()
                  item.socials = []

                  if (player.user != null) {
                    item.id = player.user.id

                    if (player.user.authorizations != null) {
                      player.user.authorizations.forEach((social) => {
                        if(social.type == "TWITTER" || social.type == "TWITCH") {
                          const account = {}
                          account.username = social.externalUsername
                          account.type = social.type
                          item.socials.push(account)
                        }
                      });
                    }
                    item.genderPronoun = player.user.genderPronoun == null ? '' : player.user.genderPronoun
                  }

                  team.members.push(item)
                })
              }

              if(set.games != null) {
                team.score = 0
                set.games.forEach((game) => {
                  if(game.winnerId === team.entrantID){
                    team.score++
                  }
                })
              }

            }
          }
        }

        return team
      },
      setOverlayValues(teamOne,teamTwo,bracketType,eventRound,bestOf) {

        if(teamOne != null) {
          if(teamOne.members != null) {
            if(teamOne.members.length > 1) {
              teamOne.members = []
            }
          }
        }
        if(teamTwo != null) {
          if(teamTwo.members != null) {
            if(teamTwo.members.length > 1) {
              teamTwo.members = []
            }
          }
        }

        this.p1 = teamOne == null ? {} : teamOne
        this.p2 = teamTwo == null ? {} : teamTwo

        this.p1Name = this.p1.name == null ? "" : this.p1.name
        this.p1Score = this.p1.score == null ? 0 : this.p1.score

        this.p2Name = this.p2.name == null ? "" : this.p2.name
        this.p2Score = this.p2.score == null ? 0 : this.p2.score

        this.bracketType = bracketType == null ? "" : bracketType.toUpperCase()
        this.eventRound = eventRound == null ? "" : eventRound.toUpperCase()
        this.bestOf = bestOf == null ? "" : bestOf.toUpperCase()
      },
      saveOverlayValuesToSession() {
        sessionStorage.setItem("teamOne",JSON.stringify(this.p1))
        sessionStorage.setItem("teamTwo",JSON.stringify(this.p2))

        sessionStorage.setItem("bracketType",this.bracketType)
        sessionStorage.setItem("eventRound",this.eventRound)
        sessionStorage.setItem("bestOf",this.bestOf)
      }
    },
    components: {
      GameplayOverlay,
    }
  }).mount('#app')

</script>

</html>
