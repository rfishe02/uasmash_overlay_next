<html>

<head>
  <title>UA Smash Upcoming</title>

  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.9.1/font/bootstrap-icons.css">

  <style>
    body {
      background-color: rgba(0, 0, 0, 0);
      margin: 0px auto;
      overflow: hidden;
    }
  </style>

  <!-- jQuery first, then Popper.js, then Bootstrap JS -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.5/dist/umd/popper.min.js" integrity="sha384-Xe+8cL9oJa6tN/veChSP7q+mnSPaj5Bcu9mPX5F5xIGE0DVittaqT5lorf0EI7Vk" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.min.js" integrity="sha384-ODmDIVzN+pFdexxHEHFBQH3/9/vQ9uori45z4JjnFsRydbmQbmL5t1tQ0culUzyK" crossorigin="anonymous"></script>

  <script src="https://unpkg.com/vue@3"></script>

</head>

<body>
  <div id="app">

      <div class="container-fluid" style="width: 1920px; height: 1080px;">

        <div class="row justify-content-left row-cols-1" style="padding-top: 15px; padding-right: 5px; padding-left: 5px;">
          <template v-for="(item,index) in setList">

            <div class="col mb-2">
              <div class="card" style="width: 18rem; background-color: rgba(255, 255, 255, 1);">
                <div class="card-body p-2">
                  <h5 class="card-title">{{item.teamOne}} vs. {{item.teamTwo}}</h5>
                  <h6 class="card-subtitle mb-2 text-muted">{{item.eventName}}: {{item.fullRoundText}}</h6>

                  <p class="card-text m-0" v-if="item.teamOne == '?' || item.teamTwo == '?'">
                    Waiting On:
                  </p>
                  
                  <ul class="list-group list-group-flush p-0" v-if="item.teamOne == '?' || item.teamTwo == '?'">
                    <li class="list-group-item pt-0 pb-0" v-if="getPreReqMatch(item.preReqId1).length > 0">{{getPreReqMatch(item.preReqId1)}}</li>
                    <li class="list-group-item pt-0 pb-0" v-if="getPreReqMatch(item.preReqId2).length > 0">{{getPreReqMatch(item.preReqId2)}}</li>
                  </ul>

                </div>
              </div>
            </div>
  
          </template>
        </div>

      </div>

    </div>

  </div>
</body>

<script type="module">

  const { createApp } = Vue

  const upcomingApp = createApp({
    data() {
      return {
        host: window.location.hostname,
        port: ":3000",
        apiKey: '',
        setList: [],
        preReqList: {},
        winnerBestOfStart: 5,
        loserBestOfStart: 5,
        finalsOrder : {
          'Round 1':0,
          'Round 2':1,
          'Round 3':2,
          'Round 4':3,
          'Round 5':4,
          'Quarter-Final':5,
          'Semi-Final':6,
          'Final':7,
          'Grand Final': 8
        },
      }
    },
    mounted() {
      
      const urlParams = new URLSearchParams(window.location.search)
      const slug = urlParams.get('slug')
      const key = urlParams.get('smashgg_key')
      
      if(key != null){
        this.apiKey = key      
      }

      if(slug != null){
        this.querySets(key,slug)
      }

      const winnerBestOfStart = urlParams.get('winnerBestOfStart') == null ? 5 : this.finalsOrder[urlParams.get('winnerBestOfStart')]
      const loserBestOfStart = urlParams.get('loserBestOfStart') == null ? 5 : this.finalsOrder[urlParams.get('loserBestOfStart')]

      if(winnerBestOfStart != null) {
        this.winnerBestOfStart = winnerBestOfStart
      }
      if(loserBestOfStart != null) {
        this.loserBestOfStart = loserBestOfStart
      }

    },
    methods : {
      async querySets(key,slug) {

        const sets = await this.querySetsSmashGG(key,slug)
        const priorQueue = {}
        const newQueueIdSet = new Set()
        const removeIndex = []

        this.setList.forEach(item => {
          priorQueue[item.id] = item
        })

        sets.forEach(item => {
          const match = priorQueue[item.id] 

          if(match == null) {
            this.setList.push(item)
          } else {
            match.teamOne = item.teamOne
            match.teamTwo = item.teamTwo
          }

          newQueueIdSet.add(item.id)
          this.preReqList[item.id] = item
        })

        for(var i = 0; i < this.setList.length; i++){
          if(!newQueueIdSet.has(this.setList[i].id)) {
            removeIndex.push(this.setList[i].id)
          }
        }

        removeIndex.forEach(index => {
          this.setList.splice(index,1)
        })

      },
      async querySetsSmashGG(key,slug) {
        const setQueryData = []
        const query = `
        query MyQuery($slug: String) {
          tournament(slug:$slug){
            name
            events {
              name
              state
            sets (
              sortType: CALL_ORDER
              filters: {
                hideEmpty: true
                state: [1,2]
              }
            ) {
                nodes {
                  id 
                  state 
                  identifier
                  fullRoundText
                  phaseGroup {
                    phase {
                      name
                    }
                  }
                  slots {
                    prereqId
                    entrant {
                      name
                    }
                  }
                }
              }
            }
          }
        }`

        try {

          const response = await fetch("https://api.start.gg/gql/alpha", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
              Authorization: "Bearer " + key,
            },
            body: JSON.stringify({
              query,
              variables: { slug: slug },
            }),
          })

          if(response.ok){
            const data = await response.json()

            if(data.data != null){
              if(data.data.tournament != null){

                if(data.data.tournament.events != null){
                  data.data.tournament.events.forEach(event => {
                    
                    if(event.state != null) {
                      if(event.state == 'ACTIVE'){
                        
                        if(event.sets != null){
                          if(event.sets.nodes != null) {
                            event.sets.nodes.forEach(set => {
                              const s = {id: '', preReqId1: '', preReqId2: '', eventName:'', fullRoundText: '', phaseName: '', teamOne: '?', teamTwo: '?', bestOf: 'Best of 3'}
                              s.id = set.id 

                              s.eventName = event.name == null ? '' : event.name
                              if(s.eventName.length > 30) {
                                s.eventName = s.eventName.slice(0,30) + "... "
                              }

                              s.fullRoundText = set.fullRoundText == null ? '' : set.fullRoundText
                            
                              if(set.phaseGroup != null){
                                if(set.phaseGroup.phase != null){
                                  s.phaseName = set.phaseGroup.phase.name == null ? '' : set.phaseGroup.phase.name
                                }
                              }
                            
                              if(set.slots != null){
                                if(set.slots[0] != null){
                                  s.preReqId1 = set.slots[0].prereqId
                                  if(set.slots[0].entrant != null) {
                                    s.teamOne = set.slots[0].entrant.name.slice(set.slots[0].entrant.name.indexOf("| ") + 1,set.slots[0].entrant.name.length).trim()
                                  }
                                }
                              
                                if(set.slots[1] != null){
                                  s.preReqId2 = set.slots[1].prereqId
                                  if(set.slots[1].entrant != null) {
                                    s.teamTwo = set.slots[1].entrant.name.slice(set.slots[1].entrant.name.indexOf("| ") + 1,set.slots[1].entrant.name.length).trim()
                                  }
                                }
                              }
                            
                              const eventRound = set.fullRoundText == null ? '' : set.fullRoundText
                              const order = this.finalsOrder[eventRound.replace(/Winners |Losers /g,'')]
                            
                              if(order != null) {
                                if(eventRound.indexOf('Winner') >= 0) {
                                  if(order >= this.winnerBestOfStart) {
                                    s.bestOf = 'Best of 5'
                                  }
                                } else {
                                  if(order >= this.loserBestOfStart) {
                                    s.bestOf = 'Best of 5'
                                  }
                                }
                              }
                            
                              setQueryData.push(s)
                            })
                          }
                        }

                      }
                    }

                  })
                }

              }
            }
          }

        } catch(e){
          console.log(e)
        }

        console.log(setQueryData)
        return setQueryData
      },
      getPreReqMatch(id) { 
        if(this.preReqList[id] != null) {
          return this.preReqList[id].teamOne + " vs. " + this.preReqList[id].teamTwo
        } else {
          return ''
        }
      }
    },
    components: {

    }
  }).mount('#app')

</script>

</html>
